import asyncio import os import json import streamlit as st from typing import Dict, Any from dotenv import load_dotenv from langchain_mcp_adapters.client import MultiServerMCPClient load_dotenv() st.set_page_config(page_title="GitHub MCP Tool Explorer", layout="wide")  GITHUB_SERVER_NAME = "github"  async def get_mcp_client() -> MultiServerMCPClient:     """Create an MCP client configured for GitHub."""     github_url = os.environ.get("GITHUB_MCP_URL")     github_pat = os.environ.get("GITHUB_PAT")          if not github_url or not github_pat:         raise ValueError("GITHUB_MCP_URL and GITHUB_PAT must be set in .env")      servers_config: Dict[str, Any] = {         GITHUB_SERVER_NAME: {             "transport": "streamable_http",             "url": github_url,             "headers": {                 "Authorization": f"Bearer {github_pat}",             },         }     }     client = MultiServerMCPClient(connections=servers_config)     return client  async def init_state():     """Initialize session state with tools."""     if "client" not in st.session_state:         st.session_state.client = None     if "tools" not in st.session_state:         st.session_state.tools = []      try:         if not st.session_state.client:              with st.spinner("Connecting to GitHub MCP..."):                 client = await get_mcp_client()                 st.session_state.client = client                  if not st.session_state.tools and st.session_state.client:             with st.spinner("Fetching tools..."):                 tools = await st.session_state.client.get_tools()                 st.session_state.tools = tools                      except Exception as e:         st.error(f"Initialization Error: {e}")  def main():     st.title("GitHub MCP Explorer")          # Sidebar status     with st.sidebar:         st.header("Connection Status")         if "tools" in st.session_state and st.session_state.tools:              st.success(f"Connected. {len(st.session_state.tools)} tools loaded.")         else:              st.warning("Not connected.")         if st.button("Refresh Tools"):              st.session_state.tools = []              st.session_state.client = None              st.rerun()      # Async init     if "tools" not in st.session_state or not st.session_state.tools:         asyncio.run(init_state())      if not st.session_state.tools:         st.info("Please configure .env and ensure the MCP server is running.")         return     tool_names = [t.name for t in st.session_state.tools]     selected_tool_name = st.selectbox("Select Tool", tool_names)     selected_tool = next((t for t in st.session_state.tools if t.name == selected_tool_name), None)      if selected_tool:         st.markdown(f"**{selected_tool.name}**: {selected_tool.description}")         st.markdown("---")                  # Dynamic Form         inputs = {}         if selected_tool.args_schema:             if isinstance(selected_tool.args_schema, dict):                 schema = selected_tool.args_schema             else:                 schema = selected_tool.args_schema.schema()             properties = schema.get("properties", {})             required = schema.get("required", [])              with st.form(key=f"form_{selected_tool_name}"):                 st.subheader("Parameters")                 for arg_name, arg_info in properties.items():                     label = f"{arg_name} {'*' if arg_name in required else ''}"                     arg_type = arg_info.get("type", "string")                     default = arg_info.get("default", None)                     help_text = arg_info.get("description", "")                                          # Special handling for array types (like files in push_files)                     if arg_type == "array" or arg_name == "files":                         example_json = '[{"path": "file.txt", "content": "hello"}]'                         help_text = f"Enter as JSON array. {help_text}\nExample: {example_json}"                         inputs[arg_name] = st.text_area(                             label,                              value=json.dumps(default) if default else example_json,                             height=150,                             help=help_text                         )                     elif arg_type == "boolean":                         inputs[arg_name] = st.checkbox(label, value=bool(default) if default is not None else False, help=help_text)                     elif arg_type == "integer":                          inputs[arg_name] = st.number_input(label, value=int(default) if default is not None else 0, step=1, help=help_text)                     else:                         inputs[arg_name] = st.text_input(label, value=str(default) if default is not None else "", help=help_text)                  submitted = st.form_submit_button("Run Tool")         else:              with st.form(key=f"form_{selected_tool_name}"):                  st.info("No parameters required.")                  submitted = st.form_submit_button("Run Tool")          if submitted:             async def run():                 # Parse JSON fields if they're arrays                 parsed_inputs = inputs.copy()                 if selected_tool.args_schema:                     if isinstance(selected_tool.args_schema, dict):                         schema = selected_tool.args_schema                     else:                         schema = selected_tool.args_schema.schema()                     properties = schema.get("properties", {})                                          for arg_name, arg_info in properties.items():                         arg_type = arg_info.get("type", "string")                         if (arg_type == "array" or arg_name == "files") and arg_name in parsed_inputs:                             try:                                 parsed_inputs[arg_name] = json.loads(parsed_inputs[arg_name])                             except json.JSONDecodeError as e:                                 raise ValueError(f"Invalid JSON in {arg_name}: {e}")                                  return await selected_tool.ainvoke(parsed_inputs)              with st.spinner(f"Running {selected_tool_name}..."):                 try:                     result = asyncio.run(run())                     st.success("Success")                     st.json(result)                 except Exception as e:                     st.error(f"Execution failed: {e}")  if __name__ == "__main__":     main()